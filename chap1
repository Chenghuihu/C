习题
1.1 下面这个简单的的程序实现了一种长效的（persistent）函数式二叉搜索树，使得如果 tree2 = insert(x, tree1)，则当使用 tree2 时，tree1 仍可以继续用于查找。

typedef struct tree *T_tree;
struct tree{
	T_tree left;
	String key;
	T_tree right;
};
T_tree Tree(T_tree l,String k,T_tree r){
	T_tree t=checked_malloc(sizeof(*t));
	t->left=l;
	t->key=k;
	t->right=r;
	return t;
}
T_tree insert(String key,T_tree t){
	if(t==NULL)  return Tree(NULL,key,NULL);
	else if(strcmp(key,t->key)<0)
			return Tree(insert(key,t->left),t->key,t->right);
	else if(strcmp(key,t->key)>0)
			return Tree(t->left,t->key,insert(key,t->right));	
	else  return Tree(t->left,key,t->right);
} 


a. 实现函数 member，若查找到了相应项，返回 TRUE；否则返回 FALSE。

Bool member(String key,T_tree t){
	while(t){
		if(key>t->key)
			t=t->right;
		else if(key<t->key)
			t=t->left;
		else
			return True;
	}
	return False;
}

b. 扩充这个程序使其不仅能判别成员关系，而且还能将键值映射到其绑定层。

T_tree insert(String key,void *binding,T_tree t){
	if(t==NULL)  return Tree(NULL,key,NULL,binding);
	else if(strcmp(key,t->key)<0)
			return Tree(insert(key,binding,t->left),t->key,t->right,binding);
	else if(strcmp(key,t->key)>0)
			return Tree(t->left,t->key,insert(key,binding,t->right),binding);	
	else  return Tree(t->left,key,t->right);
} 

void * lookup(String key,T_tree t){
	if(!t){
		return NULL;
	}
	if(key>t->key)
		return lookup(key,t->right);
	else if(key<t->key)
		return lookup(key,t->left);
	else
		return t;
}
